a(L,L) | b(L,L) :- c(L), L>1.
a(L,M) :- b(M,L), c(L), L<3.
b(M,L) :- a(M,X), c(L), not c(X).

c(2). c(3). b(1,2). b(2,3).


%%%%% Prima passata %%%%%
a(2,2) | b(2,2).            % :- c(2).
a(3,3) | b(3,3).            % :- c(3).

a(2,1) :- b(1,2).            %, c(2).

b(2,2) :- a(2,1).     %,c(2) , not c(1)
b(2,3) :- a(2,1).     %,c(3) , not c(1)

a(2,2) :- b(2,2).               %,c(2).

        %b(2,2) :- a(2,2),c(2), not c(2).
        %b(3,3) :- a(3,3),c(3), not c(3).
                                    

c(2). c(3). b(1,2). b(2,3). a(2,2). a(3,3). a(2,1). b(2,2).         %CORRETTO

c(2). c(3). b(1,2). b(2,3). b(2,2). b(3,3). a(2,1). a(2,2).         %CORRETTO       BEST

c(2). c(3). b(1,2). b(2,3). a(2,2). b(3,3). a(2,1). b(2,2).         %è lo stesso di quello di sopra

c(2). c(3). b(1,2). b(2,3). b(2,2). a(3,3). a(2,1). a(2,2).         %è lo stesso di quello di sopra

c(2). c(3). b(1,2). b(2,3). b(2,2). a(3,3). a(2,1). a(2,2).         %è lo stesso di quello di sopra

c(2). c(3). b(1,2). b(2,3). a(2,2). b(3,3). a(2,1). b(2,2).         %è lo stesso di quello di sopra

%%%%%%%% PUNTO 2 %%%%%%%%%%%%%
:~ a(X,Y). [X @ Y]


% PRIMO AS
:~ a(2,2).[2@2]
:~ a(3,3).[3@3]
:~ a(2,1).[2@1]

% SECONDO AS
:~ a(2,1).[2@1]
:~ a(2,2).[2@2]




%%%%%%%% PUNTO 3 %%%%%%%%%%%%%
% c) Si immagini ora di voler minimizzare (al livello di priorità più basso) i casi in cui compaiono
% coppie del tipo “b(W,Z), a(Z,W)”. Si definisca un opportuno weak constraint, lo si aggiunga al
% programma ottenuto al punto (b) e si calcolino nuovamente i costi per tutti gli answer set,
% indicando quello ottimo e commentando il procedimento seguito.

:~ b(W,Z), a(Z,W). [1@1]



c(2). c(3). b(1,2). b(2,3). a(2,2). a(3,3). a(2,1). b(2,2).

c(2). c(3). b(1,2). b(2,3). b(2,2). b(3,3). a(2,1). a(2,2).         %BEST [4@1][2@2]

:~ a(X,Y). [X @ Y]
:~ b(W,Z), a(Z,W). [1@1]

% PRIMO AS
:~ a(2,2).[2@2]
:~ a(3,3).[3@3]
:~ a(2,1).[2@1]

:~ b(1,2), a(2,1). [1@1]
:~ b(2,2), a(2,2). [1@1]

% SECONDO AS
:~ a(2,1).[2@1]
:~ a(2,2).[2@2]

:~ b(1,2), a(2,1). [1@1]
:~ b(2,2), a(2,2). [1@1]






%%%%%%%%%%%%%%%%%%%%%%%% ESERCIZIO 2 %%%%%%%%%%%%%%%%%%%%%%%%
Esercizio 2.
% Si scriva un programma ASP che risolva il problema seguente: dato un insieme di persone V, una
% relazione (simmetrica) di amicizia tra essi ed un insieme di tavoli T, ciascuno avente esattamente
% 3 posti, assegnare alcuni delle persone di V ai tavoli, tenendo conto di quanto esposto di seguito.
% • Non tutte le persone devono per forza finire seduti ad un qualche tavolo.
% • Ciascun tavolo deve essere lasciato vuoto oppure occupato interamente da 3 persone.
% • Se 3 persone sono sedute allo stesso tavolo, tutte sono amiche tra loro (cioè, se a,b,c sono
% allo stesso tavolo, allora a deve essere amico di b e di c; b di c di a, e c di a e di b).
% • Si vuole massimizzare il numero di tavoli usati (cioè non vuoti).
% Modello dei dati in INPUT:
% • persona(X)  le persone da far sedere
% • amici(X,Y)  la relazione di amicizia tra due persone X e Y
% • tavolo(T)  i tavoli a disposizione

persona(1..5).
amici(X,Y) :- persona(X), persona(Y).
amici(X,Y) :- amici(Y,X).
tavolo(1..3).

seduti(P,T) | notseduti(P,T) :- persona(P),tavolo(T).

:-persona(P), seduti(P,T1),seduti(P,T2),T1!=T2.

%   • Ciascun tavolo deve essere lasciato vuoto oppure occupato interamente da 3 persone.
:- #count{P:seduti(P,T)} = K, K != 0, K != 3, tavolo(T).


% • Se 3 persone sono sedute allo stesso tavolo, tutte sono amiche tra loro (cioè, se a,b,c sono
% allo stesso tavolo, allora a deve essere amico di b e di c; b di c di a, e c di a e di b).
amicizia(P1,P2,P3) :- amici(P1,P2),amici(P1,P3),amici(P3,P2).
:- #count{P:seduti(P,T)}=3,tavolo(T), not amicizia(P1,P2, P3),seduti(P1,T),seduti(P2,T),seduti(P3,T).