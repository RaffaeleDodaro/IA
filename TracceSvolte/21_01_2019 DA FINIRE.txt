%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%      ESERCIZIO 1      %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

a(Z) :- c(Z,Y), not b(Y), Y=Z+1.
c(Y,Z) :- a(Y), b(Z), not a(Z).
c(Y,Y) | b(Y) :- a(Y), not b(Y).
c(3,4).
a(2).
b(3).

a(3).                               % c(3,4), not b(4)
                                    %c(2,3) :- not a(3).                             % a(2),b(3),       %corpo falso --> sempre verificata
c(2,2) | b(2) :- not b(2).                      % a(2), 


a(2):-c(2,3), not b(3).            %corpo falso --> sempre verificata
c(3,3):-a(3),b(3), not a(3).       %corpo falso --> sempre verificata
c(2,3):-a(2),b(3),not a(3).        %corpo falso --> sempre verificata
c(2,2):-a(2),b(2),not a(2).        %corpo falso --> sempre verificata
c(3,2):-a(3),b(2),not a(2).        %corpo falso --> sempre verificata

c(3,3) | b(3) :-a(3), not b(3).    %corpo falso --> sempre verificata


c(3,4). a(2). b(3). a(3). c(2,2). 

c(3,4). a(2). b(3). a(3). b(2).                      % lo posso cancellare perche' non e' supportato b(2)-->prendo l'atomo da verificare e vedo se e' in testa ad una regola con corpo vero



%%%%%%%%%%%%%
%   PTA-2   %
%%%%%%%%%%%%%

:- #count{X:b(X), not a(X)}<2.
c(3,4). a(2). b(3). a(3). c(2,2). 
% :- non voglio che 1<2
--> INCONSITSTENTE




%%%%%%%%%%%%%
%    PTB    %
%%%%%%%%%%%%%

A1: {girasole(1,4), girasole(2,4), girasole(1,3), girasole(2,3), margherita(5,1)}
A2: {girasole(1,4), girasole(2,4), margherita(4,3), girasole(1,1), girasole(2,1)}
A3: {margherita(1,4), girasole(1,3), girasole(2,3), girasole(1,1), girasole(2,1)}
A4: {girasole(1,4), girasole(2,4), girasole(1,3), girasole(2,3), girasole(1,1), girasole(2,1)}

% ASP-Core-2 syntax
:~ girasole(X,Y), X<Y. [X@Y, X,Y]
:~ girasole(X,W), girasole(Y,Z), not margherita(X,Y). [X@Y,X,Y,W,Z]

% A1: {girasole(1,4), girasole(2,4), girasole(1,3), girasole(2,3), margherita(5,1)}             [12@1]  [12@2]  [3@3]  [3@4]
:~ girasole(1,4), 1<4. [1@4, 1,4]
:~ girasole(2,4), 2<4. [2@4, 2,4]
:~ girasole(1,3), 1<3. [1@3, 1,3]
:~ girasole(2,3), 2<3. [2@3, 2,3]
                       [3@4]
                       [3@3]

:~ girasole(1,4), girasole(1,4), not margherita(1,1). [1@1,1,1,4,4]
:~ girasole(1,4), girasole(2,4), not margherita(1,2). [1@2,1,2,4,4]
:~ girasole(1,4), girasole(1,3), not margherita(1,1). [1@1,1,1,4,3]
:~ girasole(1,4), girasole(2,3), not margherita(1,2). [1@2,1,2,4,3]

:~ girasole(2,4), girasole(2,4), not margherita(2,2). [2@2,2,2,4,4]
:~ girasole(2,4), girasole(1,4), not margherita(2,1). [2@1,2,1,4,4]
:~ girasole(2,4), girasole(1,3), not margherita(2,1). [2@1,2,1,4,3]
:~ girasole(2,4), girasole(2,3), not margherita(2,2). [2@2,2,2,4,3]

:~ girasole(1,3), girasole(1,3), not margherita(1,1). [1@1,1,1,3,3]
:~ girasole(1,3), girasole(1,4), not margherita(1,1). [1@1,1,1,3,4]
:~ girasole(1,3), girasole(2,4), not margherita(1,3). [1@2,1,2,3,4]
:~ girasole(1,3), girasole(2,3), not margherita(1,3). [1@2,1,2,3,3]

:~ girasole(2,3), girasole(2,3), not margherita(2,2). [2@2,2,2,3,3]
:~ girasole(2,3), girasole(1,4), not margherita(2,2). [2@1,2,1,3,4]
:~ girasole(2,3), girasole(2,4), not margherita(2,2). [2@2,2,2,3,4]
:~ girasole(2,3), girasole(1,3), not margherita(2,2). [2@1,2,1,3,3]

                                                      [12@1]
                                                      [12@2]




% A2: {girasole(1,4), girasole(2,4), margherita(4,3), girasole(1,1), girasole(2,1)}                     [12@1] [14@2] [3@3]                                                
:~ girasole(X,Y), X<Y. [X@Y, X,Y]
:~ girasole(X,W), girasole(Y,Z), not margherita(X,Y). [X@Y,X,Y,W,Z]

:~ girasole(1,4), 1<4. [1@4, 1,4]
:~ girasole(2,4), 2<4. [2@4, 2,4]
:~ girasole(1,2), 1<2. [2@1, 2,1]
                        [3@4]
                        [2@1]


:~ girasole(1,4), girasole(1,4), not margherita(1,1). [1@1,1,1,4,4]
:~ girasole(1,4), girasole(2,4), not margherita(1,2). [1@2,1,2,4,4]
:~ girasole(1,4), girasole(1,1), not margherita(1,1). [1@1,1,1,4,1]                        
:~ girasole(1,4), girasole(2,1), not margherita(1,2). [1@2,1,2,4,1]



:~ girasole(2,4), girasole(1,4), not margherita(2,1). [2@1,2,1,4,4]
:~ girasole(2,4), girasole(2,4), not margherita(2,2). [2@2,2,2,4,4]
:~ girasole(2,4), girasole(1,1), not margherita(2,1). [2@1,2,1,4,1]                        
:~ girasole(2,4), girasole(2,1), not margherita(2,2). [2@2,2,2,4,1]


:~ girasole(1,1), girasole(1,1), not margherita(1,1). [1@1,1,1,1,1]
:~ girasole(1,1), girasole(2,4), not margherita(1,2). [1@2,1,2,1,4]
:~ girasole(1,1), girasole(1,4), not margherita(1,1). [1@1,1,1,1,4]                        
:~ girasole(1,1), girasole(2,1), not margherita(1,2). [1@2,1,2,1,1]


:~ girasole(2,1), girasole(2,1), not margherita(2,2). [2@2,2,2,1,1]
:~ girasole(2,1), girasole(2,4), not margherita(2,2). [2@2,2,2,1,4]
:~ girasole(2,1), girasole(1,1), not margherita(2,1). [2@1,2,1,1,1]                        
:~ girasole(2,1), girasole(2,1), not margherita(2,2). [2@2,2,2,1,1]

                                                      [10@1]
                                                      [14@2]

% A3: {margherita(1,4), girasole(1,3), girasole(2,3), girasole(1,1), girasole(2,1)}         COST 3@3 12@2 12@1                  BEST


% A4: {girasole(1,4), girasole(2,4), girasole(1,3), girasole(2,3), girasole(1,1), girasole(2,1)}        COST 3@4 3@3 27@2 27@1








%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%      ESERCIZIO 2      %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Renata Limbranata, la mogliettina del nostro vecchio amico Ciccio Pasticcio, ha di recente  
iniziato  a  frequentare  un  esclusivo  circolo  tennistico  alle  porte  di  Pasticciopoli.  
È  tutta presa dalla sua nuova passione, e questo lascia a Ciccio un po’ di tregua... o almeno 
così credeva lui! Infatti,la nuova direttrice tecnica del circolo, Fiammetta Laracchetta, ha in 
mente un nuovo sistema   di   allenamento   piuttosto   complesso,   che   richiede   la   
formazione   di   squadre   e   di accoppiamenti tra i soci. Poteva Renata non chiamare in causa 
il suo adorato marito? Ovviamente no, e pertanto ora ci tocca aiutare Ciccio a scrivere un programma 
ASP che si occupi di ottenere quanto indicato di seguito.

• Ogni giocatore deve essere assegnato ad una squadra. Il numero di squadre massimo è noto
all’inizio. Si tenga presente che il numero di squadre create può essere minore di quello
massimo (cioè non tutte le squadre devono per forza avere dei giocatori assegnati, mentre
ogni giocatore deve finire esattamente in una squadra).

id(1..10).
sesso(1..2).
forza(1..10).
team(1..5).


player(X,Y,Z) | notPlayer(X,Y,Z) :- id(X), sesso(Y), forza(Z).
:-player(X,Y,Z), player(H,J,K), id(X),sesso(Y),forza(Z),X==H,Y!=J,Z!=K.

inTeam(P,T)| notInTeam(P,T):-player(P,Y,Z),team(T).
:-inTeam(P,X), inTeam(P,Y), X!=Y.

isAssigned(P) :- player(P,Y,Z),inTeam(P,_).
:-player(P,_,_), not isAssigned(P).


• Se un team non è vuoto, allora deve contenere giocatori di entrambi i sessi.
entrambiSessi(T):-inTeam(P1,T),inTeam(P2,T), player(P1,1,F1),player(P2,2,F2), team(T).
:-#count{P:inTeam(P,T)}>1,team(T), not entrambiSessi(T).

• Un primo desiderio, il meno importante di tutti, è che la forza complessiva (cioè la somma
delle forze di ciascun membro) delle squadre sia bilanciata. In altri termini, date le forze
complessive di due qualunque tra le squadre formate, se ne vuole minimizzare la differenza.
forzaTotale(T,K):team(T),#sum{F1,T:player(P1,_,F1), inTeam(P1,T)}=K.


• La formula dell’allenamento prevede che ciascun team giochi esattamente contro un altro,
e che i tutti membri di un team giochino contro tutti quelli del team accoppiato. Si devono
pertanto stabilire gli accoppiamenti tra i team.
play(T1,T2)|notPlay(T1,T2):-team(T1),team(T2),T1!=T2.
:-play(T1,T2),play(T1,T3), T2!=T3.


• Sono note delle statistiche calcolate sullo storico degli allenamenti nel circolo; in particolare,
si ha un grafo orientato pesato i cui nodi sono i giocatori, e in cui esiste un arco <a,b,wa>
se il giocatore “a” ha vinto “wa” incontri giocando contro il giocatore “b”; in questo caso,
esisterà sempre anche un arco <b,a,wb> che indica quante volte il giocatore “b” ha battuto
il giocatore “a”. “wb+wa” è il numero totale di incontri tra “a” e “b”. Pertanto, se due
giocatori non hanno mai giocato, non ci sono archi tra loro; altrimenti c’è sempre una coppia
di archi come quelli descritti (si noti che qualche arco potrebbe avere peso pari a zero, se
uno dei giocatori non ha mai battuto l’altro).





• Nello stabilire gli accoppiamenti:
        o la cosa più importante è massimizzare il numero di incontri che si verificheranno tra
        giocatori che non si sono mai incontrati prima;
        match(A,B):-played(A,B).
        match(A,B):-match(B,A).
        noIncontri(A,B):-player(A,_,_),player(B,_,_), not match(A,B), A!=B.



        o se due giocatori che dovranno giocare a causa dell’accoppiamento tra i team si sono
        già incontrati in precedenza, si vuole minimizzare la differenza tra le mutue vittorie.
        vittorie(A,B,C):- played(A,B,C1), played(A,B,C2), C=C1-C2.


• Al fine di arricchire le statistiche, si desidera inoltre calcolare il numero totale di incontri
già disputati tra gli accoppiamenti che si sono venuti a creare con le nostre scelte.





Modello dei dati in input
    player(ID,Gender,Strength)  I giocatori del circolo, con il loro sesso e la loro forza stimata
    team(ID)  I possibili team che si possono comporre
    played(P1,P2,NWin)  Le informazioni su incontri precedenti tra i giocatori del circolo



Modello dei dati in output
    inTeam(Player,Team)  La formazione dei team
    play(Team1,Team2)  Gli accoppiamenti tra i team
    history(N)  Il numero di incontri già disputati tra giocatori che si incontreranno da ora in poi








%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%      ESERCIZIO 3      %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
a(Z) :- c(Z,X), b(Z).
c(f(Y),f(Z)):- a(Y), a(Z).

c(1,f(1)). b(f(1)). b(1).

a(1).               % :- c(1,f(1)), b(1)
c(f(1),f(1)).       % :- a(1), a(1)
a(f(1)).            % :- c(f(1),f(1)), b(f(1))

c(f(1),f(f(1))).    %:- a(1), a(f(1))

c(f(f(1)),f(1)).    %:- a(f(1)), a(1)

c(f(f(1)),f(f(1))).     % :- a(f(1)), a(f(1))

a(f(1)).                % :- c(f(1),X), b(f(1))

c(1,f(1)). b(f(1)). b(1). a(1). c(f(1),f(1)). a(f(1)). c(f(1),f(f(1))).  c(f(f(1)),f(1)). c(f(f(1)),f(f(1))). 